---
layout: post
title: "월반멘토링 4주차 set 풀이"
categories: ['ALOHA']
comments: true
---
<script type="text/javascript" 
src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
</script>
방학이 끝나간..드아..
어째 풀이가 불친절해지는거 같으면 기분탓이 아니에요 ~~더위 먹어서 힘들어..~~

### **DP(Interval DP) / LIS / LCS**
#### **1. 증가하는 부분 수열의 개수 (Silver II)**
> tag : lis($$\scriptsize O(N^{2})$$)

$$\scriptsize i$$번째 원소로 끝나는 LIS의 개수를 세는 문제다.

> $$\small dp(i) := "i$$번째 원소로 끝나는 LIS 개수"

라고 정의하면 된다. 그러면, 당연하게도 다음과 같은 점화식을 얻는다.

> $$\small dp(i) = \sum_{j < i \wedge arr(j) < arr(i)}dp(j) $$

이 점화식은 $$\scriptsize O(N^{2})$$에 계산할 수 있으므로, 시간내에 결과를 다 구할 수 있다. 따라서, DP 테이블을 채우고 출력하면 AC.

<details>
<summary style = "cursor: pointer">코드 보기</summary>
<div markdown = "1">

```cpp
#include <bits/stdc++.h>

using namespace std;
using ll = long long;
using pii = pair<int, int>;
using ppii = pair<int, pii>;

ll A[5050];
ll dp[5050];
const ll MOD = 998244353LL;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    int N; cin >> N;
    for(int i = 1; i <= N; ++i) cin >> A[i];

    for(int i = 1; i <= N; ++i) {
        dp[i] = 1;
        for(int j = 1; j < i; ++j) {
            if(A[j] < A[i]) {
                dp[i] += dp[j];
                dp[i] %= MOD;
            }
        }
    }

    for(int i = 1; i <= N; ++i) cout << dp[i] % MOD << ' ';

    return 0;
}
```
</div>
</details>

#### **2. 전깃줄 (Gold V)**
> tag : lis

교차하지 않으려면 $$\scriptsize A$$전봇대의 낮은 번호에서부터 볼 때, $$\scriptsize B$$에 연결되어 있는 번호들이 증가하는 모습을 보여야 한다.
연결된 번호가 감소한다면 교차한다는 의미이다.

문제에서 구하는 것은 교차하지 않도록 하기 위해 없애야 하는 최소 전선의 개수이다. 반대로 생각해보자. 가장 긴 증가하는 부분 수열의 길이가 바로 교차하지 않으며 존재할 수 있는 최대 전선의 개수이다. 즉 LIS의 길이를 찾고 **(전체 전선 개수 - LIS 길이)**을 해주면 정답이다.

이때, $$\scriptsize N$$의 크기가 100으로 작기 때문에, $$\scriptsize O(N^{2})$$짜리 시간복잡도로 LIS 길이를 구해도 된다. 전봇대 $$\scriptsize A$$에 연결된 $$\scriptsize B$$ 위치를 차례대로 넣어두고, LIS를 찾으면 된다. 

<details>
<summary style = "cursor: pointer">코드 보기</summary>
<div markdown = "1">

```cpp
#include <iostream>
#include <vector>
#include <utility>
#include <algorithm>

using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr); cout.tie(nullptr);

    int N; cin >> N;
    vector<int> dp(N, 1);

    vector<pair<int, int>> seq(N);
    for(int i = 0; i < N; ++i) cin >> seq[i].first >> seq[i].second;
    sort(seq.begin(), seq.end());

    for(int i = 0; i < N; ++i) {
        for(int j = 0; j < i; ++j) {
            if(seq[i].second > seq[j].second) {
                dp[i] = max(dp[i], 1 + dp[j]);
            }
        }
    }

    int lis = *max_element(dp.begin(), dp.end());

    cout << N - lis << '\n';

    return 0;
}
```
</div>
</details>


#### **3. 최장 최장 증가 부분 수열 (Gold V)**
> tag : lis

문제를 잘 읽어보면, 2차원에서 LIS를 구하는 문제라 생각할 수 있다.
이때, 최단경로로 이동하므로 오른쪽과 아래쪽으로만 움직일 수 있다.

1차원에서 LIS를 구할 때 정의했던 식과 비슷하게 dp식을 정의해보자.

> $$\small dp(i, j) := "(i, j)$$까지 만들 수 있는 최장 증가 부분 수열의 길이"
>
> $$\small dp(i, j) = \max_{arr(r, c) < arr(i, j)}dp(r, c) + 1$$
>
> 단, $$\small r \leq i \wedge c \leq j \wedge (r, c) \neq (i, j) $$

따라서, DP 테이블은 $$\scriptsize O(N^{4})$$에 구할 수 있다. $$\scriptsize N = 100$$이라서, 충분히 구할 수 있다.

여담으로, 원래 출제자는 이걸 이차원 세그먼트 트리로 최적화 하는.. 문제로 내려 했었답니다. 그걸로 풀면 $$\scriptsize O(N^{2}log^{2}N)$$에 풀림.

<details>
<summary style = "cursor: pointer">코드 보기</summary>
<div markdown = "1">

```cpp
#include <bits/stdc++.h>

using namespace std;
using ll = long long;
using pii = pair<int, int>;
using ppii = pair<int, pii>;

int dp[101][101];
int m[101][101];
int N; 

int solve(int i, int j) {
    int& ret = dp[i][j];

    if(ret != -1) return ret;

    ret = 1;
    for(int r = 1; r <= i; ++r) {
        for(int c = 1; c <= j; ++c) {
            if(r == i && c == j) continue;
            if(m[r][c] < m[i][j]) ret = max(ret, solve(r, c) + 1);
        }
    }

    return ret;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    cin >> N;
    for(int i = 1; i <= N; ++i) {
        fill(dp[i], dp[i] + 101, -1);
        for(int j = 1; j <= N; ++j) {
            cin >> m[i][j];
        }
    }

    int ans = 0;
    for(int i = 1; i <= N; ++i) {
        for(int j = 1; j <= N; ++j) {
            ans = max(ans, solve(i, j));
        }
    }

    cout << ans << '\n';

    return 0;
}
```

</div>
</details>

#### **4. LCS2 (Gold IV)**
> tag : LCS

LCS를 구하고, LCS 중 하나를 출력하면 된다. 간단히 말하면 LCS를 역추적하는 문제다.

```cpp
void traceLCS(string& str, int a, int b) {
    vector<char> ret;
    while(a >= 0 && b >= 0) {
        if(dp[a][b] == dp[a - 1][b]) a--;
        else if(dp[a][b] == dp[a][b - 1]) b--;
        else {
            ret.push_back(str[a]);
            a--; b--;
        }
    }
}
```

```dp[a][b] == dp[a - 1][b]```이면, 왼쪽을 감소시키면 된다. 반대로 ```dp[a][b] == dp[a][b - 1]```이면, 오른쪽을 감소시키자. 저 두 경우가 아니면 dp값에 변화가 있어야 했던 부분이니까 둘 다 감소시켜주자. 이런식으로 LCS의 실제값을 구해낼 수 있다. 이해가 안된다면, 직접 dp값을 써보면서 이해하는걸 추천함.

<details>
<summary style = "cursor: pointer">코드 보기</summary>
<div markdown = "1">

```cpp
// https://www.acmicpc.net/problem/9251 //
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int dp[1001][1001];

int LCS(string& str1, string& str2, int idx1, int idx2) {
    if(idx1 < 0 || idx2 < 0) return 0;

    int& res = dp[idx1][idx2];
    if(res != -1) return res;

    if(str1[idx1] == str2[idx2]) return res = LCS(str1, str2, idx1 - 1, idx2 - 1) + 1;
    else return res = max(LCS(str1, str2, idx1 - 1, idx2), LCS(str1, str2, idx1, idx2 - 1));
}

void traceLCS(string& str, int a, int b) {
    vector<char> ret;
    while(a >= 0 && b >= 0) {
        if(dp[a][b] == dp[a - 1][b]) a--;
        else if(dp[a][b] == dp[a][b - 1]) b--;
        else {
            ret.push_back(str[a]);
            a--; b--;
        }
    }
    for(int i = ret.size() - 1; i >= 0; --i) cout << ret[i];
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    string str1, str2;
    cin >> str1 >> str2;

    for(int i = 0; i < 1001; ++i) {
        fill_n(dp[i], 1001, -1);
    }

    cout << LCS(str1, str2, str1.size() - 1, str2.size() -1) << '\n';
    traceLCS(str1, str1.size() - 1, str2.size() - 1);

    return 0;
}
```

</div>
</details>

#### **5. 파일 합치기 (Gold III)**
> tag : dp(interval dp), prefix-sum

구간을 dp 정의식에 포함해야하는 dp이다. 이거 처음 배울 때 엄청 어려웠던 기억이..
다음과 같은 dp 정의식을 떠올려보자.

> $$\small dp(i, j) := "[i, j]$$번째 파일을 합치는 데 드는 최소 비용"

라고 하면, 점화식을 하나 생각할 수 있다.

> $$\small dp(i, j) = \min_{i \leq k < j} dp(i, k) + dp(k + 1, j) + \sum_{a = i}^{j} cost(a)$$

즉, 중간 지점에서 나누어서 합치는 걸로 점화식을 세울 수 있다. $$\scriptsize [i, j]$$ 구간의 파일을 합치는 비용의 최솟값은 합쳐진 $$\scriptsize [i, k]$$ 파일과 합쳐진 $$\scriptsize [k + 1, j]$$ 파일을 합치는 비용의 최소와 같다.

이때, 두 파일을 합치는데 드는 비용은 고정적이다. 따라서, 해당 파트는 **prefix-sum** 으로 처리할 수 있다. prefix-sum은 간단히 설명하자면, 구간합을 $$\scriptsize O(1)$$에 구할 수 있도록 하는 기법이고 앞에서부터 누적합을 저장한 뒤 적절히 빼는 방식으로 사용할 수 있다. 자세한 설명은 다른 분들이 자세하게 해놨으니 따로 찾아서 공부하는걸 추천드립니다.

하여튼, 저 점화식에 의하면 테이블을 채우는데, $$\scriptsize O(N^{3})$$이니 잘 계산해주면 맞출 수 있다.

*(진짜 TMI로 Knuth Optimization(크누스 최적화)라는 것도 적용할 수 있는데.. 이걸 할 줄 알면 이 문제가 $$\scriptsize O(N^{2})$$에 풀리고, 그 문제는 심지어 플래티넘2짜리 문제다. 관심있으면 찾아보세요.)*

<details>
<summary style = "cursor: pointer">코드 보기</summary>
<div markdown = "1">

```cpp
#include <iostream>
#include <vector>
#define INF 987654321

using namespace std;

void solve(vector<int>& seq, int K) {
    vector<vector<int>> dp(K, vector<int>(K, 0));
    vector<int> sum(K + 1, 0);

    for(int i = 1; i <= K; ++i) sum[i] = sum[i - 1] + seq[i - 1];

    for(int length = 1; length < K; ++length) {
        for(int start = 0; start <= K - length - 1; ++start) {
            int end = start + length;
            dp[start][end] = INF;
            for(int pivot = start; pivot + 1 <= end; ++pivot) {
                int cost = dp[start][pivot] + dp[pivot + 1][end] + sum[end + 1] - sum[start];
                dp[start][end] = min(cost, dp[start][end]);
            }
        }
    }

    cout << dp[0][K - 1] << '\n';
}

int main() {
    int T; cin >> T;

    while(T --> 0) {
        int K; cin >> K;
        vector<int> seq(K);
        for(int i = 0; i < K; ++i) cin >> seq[i];

        solve(seq, K);
    }

    return 0;
}
```

</div>
</details>

#### **6. LCS3 (Gold III)**
> tag : LCS

아마 스트링 2개짜리 LCS 점화식을 혼자서 구할 수 있으면 진짜 쉽게 풀 수 있는 문제다. 그냥 단지 스트링이 2개에서 3개로 늘어난거기 때문에 점화식도 그에 맞춰서 확장시키면 된다.

정확히 2개짜리 LCS와 유사하게 점화식을 세우고, ```str1[i] == str2[i] == str3[i]```일때 범위를 모두 하나씩 줄여가며 LCS를 찾으면 된다. 위의 경우가 아닐때도 그냥 2개짜리 LCS와 비슷하게 해서 max값을 구하면 됨.

다만, 3개로 늘어났기에 시간복잡도는 $$\scriptsize O(N^{3})$$이 된다.

자세한 건 코드를 참고!

<details>
<summary style = "cursor: pointer">코드 보기</summary>
<div markdown = "1">

```cpp
// https://www.acmicpc.net/problem/1958 //
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

int dp[101][101][101];

int LCS(string& str1, string& str2, string& str3, int idx1, int idx2, int idx3) {
    if(idx1 < 0 || idx2 < 0 || idx3 < 0) return 0;

    int& res = dp[idx1][idx2][idx3];
    if(res != -1) return res;

    if(str1[idx1] == str2[idx2] && str2[idx2] == str3[idx3]) return res = LCS(str1, str2, str3, idx1 - 1, idx2 - 1, idx3 - 1) + 1;
    else return res = max({LCS(str1, str2, str3, idx1 - 1, idx2, idx3), LCS(str1, str2, str3, idx1, idx2 - 1, idx3), LCS(str1, str2, str3, idx1, idx2, idx3 - 1)});
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    string str1, str2, str3;
    cin >> str1 >> str2 >> str3;

    for(int i = 0; i < 101; ++i) {
        for(int j = 0; j < 101; ++j) {
            fill_n(dp[i][j], 101, -1);
        }
    }

    cout << LCS(str1, str2, str3, str1.size() - 1, str2.size() -1, str3.size() - 1);

    return 0;
}
```

</div>
</details>

#### **7. Split the GSHS (Gold III)**
> tag : ???

풀고 나중에 업데이트 할게요.

<details>
<summary style = "cursor: pointer">코드 보기</summary>
<div markdown = "1">

```cpp
// 아직 없지롱 우헤헤
```

</div>
</details>

#### **8. 최대 공통 증가 수열 (Gold I)**
> tag : ???

풀고 나중에 업데이트 할게요.

<details>
<summary style = "cursor: pointer">코드 보기</summary>
<div markdown = "1">

```cpp
// 아직 없어 우히히
```

</div>
</details>

#### **9. 팰린드롬 분할 (Gold I)**
> tag : ???

7, 8 해설과 함께 올라올 예정.
코드는 미리 첨부해놨음!

<details>
<summary style = "cursor: pointer">코드 보기</summary>
<div markdown = "1">

```cpp
#include <iostream>
#include <vector>
#include <string>
#define MAX 2500

using namespace std;

int dp[MAX];
bool isPldr[MAX][MAX];
string str;

void isPalindrome(string& str, int a, int b) {
    for(int i = 0; i <= (b - a) / 2; ++i) {
        if(str[a + i] != str[b - i]) {
            isPldr[a][b] = false;
            return;
        }
    }
    isPldr[a][b] = true;
}

int solve(string& str, int n) {
    if(n < 0) return 0;

    int& ret = dp[n];
    if(ret != -1) return ret;

    ret = MAX + 1;
    for(int k = 0; k <= n; ++k) {
        if(isPldr[k][n]) ret = min(ret, 1 + solve(str, k - 1));
    }

    return ret;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    for(int i = 0; i < MAX; ++i) dp[i] = -1; //init

    cin >> str;

    for(int i = 0; i < (int)str.size(); ++i) {
        for(int j = i; j < (int)str.size(); ++j) {
            isPalindrome(str, i, j);
        }
    }
    
    cout << solve(str, (int)str.size() - 1);

    return 0;
}
```

</div>
</details>